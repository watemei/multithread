# 一、Java多线程技术

## 技术要点
1. 线程的启动
2. 如何使线程暂停
3. 如何使线程停止
4. 线程的优先级
5. 线程安全相关问题

## 什么是线程
“电脑卡死了，清理一下”大家通常性的做法，这里清理的都是指运行在系统中的进程，如开发的打开浏览器，每新打开一个窗口都是一个新的进程，打开一个网站，会加载js、下载图片、请求数据、保存信息各式各样的操作，那么线程是什么呢？线程可以理解为执行这些的操作的载体。单线程是排队执行，也就是同步，人一般都是单线程操作，起床、上厕所、刷牙、吃饭、上班，多线程的例子比如火车站，同时有多两火车进站和出站，它是异步，很难想象要是火车站是单线程的是个什么样的场景。

一个进程运行至少有一个线程在运行，通常说的主线程，那么在Java中如何创建一个线程呢？有两种方法，一继承Thread类，二实现Runnable接口，区别是类只能单继承，接口可以无限。
注意一点：多线程是异步，代码的执行顺序与调用顺序是没有关系的。线程的调用和线程都具有随机特性，原因是你不知道CPU什么时候执行线程。

## 实例变量与线程安全
自定义线程类中的实例变量针对其他线程可以有共享与不共享之分，也是多线程之间进行交互是很重要的技术点。
1. 不共享情况下，每个线程都是独立执行没有相关性；
2. 共享情况下，多线程同时对一个变量进行修改，比如12306抢票，无数终端会同时查询、修改票数。
3. sychronized可以在任意对象与方法上加锁，加锁的这段代码叫“互斥区”或“边界区”
4. 非线程安全主要是指多个线程对同一对象同一实例变量进行操作时会出现值被修改、值不同步的情况，从而影响程序执行流程。
5. currentThread()可以返回代码正在被哪个线程调用的信息。

## 线程的方法
1. isAlive()的作用是测试线程是否处于活动状态(指的是线程已经启动尚未终止，线程处于正在运行或准备运行的状态)
2. sleep()的作用是在指定的毫秒数内让当前“正在执行的线程”休眠(暂停执行)，正在执行的线程指的是this.currentThread()返回的线程。
3. getId()的作用是取得线程的唯一标识。
4. 停止线程是在多线程开发时很重要的技术点，Thread.stop()可以停止但是不安全的,已经被弃用,Thread.interrupt()方法不能中止一个正在运行的线程。在java中有3种方法可以终止正在运行的线程，
 > 1. 使用退出标示，使线程正常退出,也就是当run方法完成后线程终止。
 > 2. 使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样，都是作废方法。
 > 3. 使用interrupt方法中断线程。

5.判断线程是否是停止状态this.interrup()是判断当前线程是否停止状态，this.isInterrupted()是测试Thread对象是否已经是中断状态，但不清除状态标志。
> 推荐:使用this.interrupted()异常配合退出

6. 暂停线程操作，使用suspend()方法暂停线程，使用resume()方法恢复线程的执行。使用不当，极易造成公共的同步对象的独占,使得其他线程无法访问公共同步对象。
7. yield方法是放弃当前的CPU资源，让它去执行其他任务，但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片
8. 程序的优先级线程可以划分优先级(1-10),优先级较高的CPU资源较多。
>1. 继承性
>2. 规则性
>3. 随机性
9. 守护线程
Java中又两种线程，一种是用户线程，一种是守护线程，守护线程是一种特殊的线程，当进程中不存在非守护线程啦，则守护线程自动销毁，典型的GC(垃圾回收器),生命周期与JVM相同。

# 对象及变量的并发访问
目标:
1. 多线程中的同步有那些知识点？
2. 如何写出线程安全的程序,需要考虑哪些因素？
3. 非线程安全有哪些问题,程序中如何解决？

技术点:
1. synchronized对象监视器为Object时的使用
2. synchronized对象监视器为Class时的使用
3. 非线程安全时如何出现的
4. 关键字volatile的主要作用
5. 关键字volatile与synchronized的区别及使用情况


## synchronized同步方法
对线程安全与非安全基本认识如下，多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果就是“脏读”,线程安全就是访问的实例变量的值是经过同步处理的，不会出现脏读现象,接下来进行更深入的分析。
1. 方法内的变量为线程安全
  从上面基本认识来看，非线程安全问题存在于实例变量,如果是方法内部的私有变量，则不存在非线程安全问题。
2. 实例变量非线程安全
  多线程同时访问1个对象中的实例变量，存在非线程安全问题，可以使用synchronized实现同步
3. 多个对象多个锁
  两个线程分别访问同一个类的两个不同实例的相同名称的同步方法，效果却是异步的方式运行，原因在于两个对象产生了2个锁，关键字synchronized取得的锁都是对象锁，而不是把一段代码或函数当作锁，多个线程调用同一个对象才有等待状态。
4. synchronized方法与锁对象
调用用关键字synchronized声明的方法一定是排队运行的，只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本就没有同步的必要。
5. 脏读
6. 出现异常，锁自动释放
7. 同步不具有继承性

### 方法内的变量为线程安全
### 实例变量非线程安全
### 多个对象多个锁
### synchronized方法与锁对象
### 脏读
### 出现异常，锁自动释放
### 同步不具有继承性
## volidate关键字
关键字volidate的主要作用是使变量在多个线程中可见。强制从公共内存中获取变量的值。但其致命缺点是不支持原子性。
